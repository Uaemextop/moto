name: "Copilot Setup Steps for LMSA Implementation"

# This workflow configures the development environment for implementing
# a production-ready version of Lenovo Mobile Software Assistant (LMSA)

on:
  workflow_dispatch:
  push:
    paths:
      - .github/workflows/copilot-setup-steps.yml
  pull_request:
    paths:
      - .github/workflows/copilot-setup-steps.yml

jobs:
  # The job MUST be named exactly "copilot-setup-steps"
  copilot-setup-steps:
    runs-on: ubuntu-latest

    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Install .NET SDK for development
      - name: Set up .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0'

      # Install ILSpy for reference to decompiled code patterns
      - name: Install ILSpy decompilation tool
        run: dotnet tool install --global ilspycmd

      # Install .NET development and testing tools
      - name: Install .NET development tools
        run: |
          dotnet tool install --global dotnet-format
          dotnet tool install --global dotnet-reportgenerator-globaltool
          dotnet tool install --global dotnet-coverage
          dotnet tool install --global dotnet-outdated-tool
          dotnet tool install --global dotnet-ef

      # Install code quality and security analyzers
      - name: Install code quality analyzers
        run: |
          dotnet tool install --global security-scan || echo "Security scan optional"
          dotnet tool install --global dotnet-sonarscanner || echo "SonarScanner optional"

      # Download reference binaries for pattern analysis
      - name: Download LMSA reference binaries
        run: |
          mkdir -p decompiled/reference
          wget -q -O /tmp/lmsa.zip "https://www.dropbox.com/scl/fi/3kuolvy11282n0q0pw99b/examples.zip?rlkey=1rldjq71q8igq0ban9lg9homn&st=07i1mewd&dl=1"
          unzip -q /tmp/lmsa.zip -d decompiled/reference
          echo "Downloaded LMSA reference binaries for analysis"

      # Recursively decompile all .NET DLLs and EXEs for open-source reimplementation
      - name: Decompile reference sources (recursive)
        run: |
          mkdir -p decompiled/reference-src

          # Helper: check if a binary is a .NET assembly before decompiling
          is_dotnet_assembly() {
            file "$1" 2>/dev/null | grep -qiE "PE32|\.NET|Mono" && \
            (strings "$1" 2>/dev/null | grep -q "mscoree\|mscorlib\|System\.Runtime" || true)
          }

          # Recursively find and decompile all .NET DLLs and EXEs
          find decompiled/reference -type f \( -iname "*.dll" -o -iname "*.exe" \) 2>/dev/null | while read binary; do
            # Derive output directory mirroring the source tree
            rel="${binary#decompiled/reference/}"
            name="${rel%.*}"
            outdir="decompiled/reference-src/${name}"
            mkdir -p "$outdir"

            # Attempt decompilation; skip non-.NET binaries gracefully
            if ilspycmd "$binary" -p -o "$outdir" 2>/dev/null; then
              echo "Decompiled: $binary -> $outdir"
            else
              echo "Skipped (not a .NET assembly or error): $binary"
              rmdir "$outdir" 2>/dev/null || true
            fi
          done

          # Print summary
          total=$(find decompiled/reference-src -name "*.cs" 2>/dev/null | wc -l)
          echo "Decompilation complete. Total .cs files generated: $total"

      # Create project structure for real implementation
      - name: Initialize LMSA project structure
        run: |
          # Create solution
          dotnet new sln -n LMSA

          # Create core library project
          dotnet new classlib -n LMSA.Core -f net8.0
          dotnet sln add LMSA.Core/LMSA.Core.csproj

          # Create device management library
          dotnet new classlib -n LMSA.DeviceManagement -f net8.0
          dotnet sln add LMSA.DeviceManagement/LMSA.DeviceManagement.csproj

          # Create plugins base library
          dotnet new classlib -n LMSA.Plugins.Common -f net8.0
          dotnet sln add LMSA.Plugins.Common/LMSA.Plugins.Common.csproj

          # Create main WPF application
          dotnet new wpf -n LMSA.App -f net8.0-windows
          dotnet sln add LMSA.App/LMSA.App.csproj

          # Create test project
          dotnet new xunit -n LMSA.Tests -f net8.0
          dotnet sln add LMSA.Tests/LMSA.Tests.csproj

          echo "Created LMSA solution structure"

      # Install required NuGet packages
      - name: Install production dependencies
        run: |
          # Core dependencies
          dotnet add LMSA.Core/LMSA.Core.csproj package Newtonsoft.Json
          dotnet add LMSA.Core/LMSA.Core.csproj package log4net
          dotnet add LMSA.Core/LMSA.Core.csproj package protobuf-net

          # Device management dependencies
          dotnet add LMSA.DeviceManagement/LMSA.DeviceManagement.csproj package SharpAdbClient
          dotnet add LMSA.DeviceManagement/LMSA.DeviceManagement.csproj package Newtonsoft.Json
          dotnet add LMSA.DeviceManagement/LMSA.DeviceManagement.csproj package log4net

          # Plugin dependencies
          dotnet add LMSA.Plugins.Common/LMSA.Plugins.Common.csproj package Newtonsoft.Json

          # WPF application dependencies
          dotnet add LMSA.App/LMSA.App.csproj package Microsoft.Xaml.Behaviors.Wpf
          dotnet add LMSA.App/LMSA.App.csproj package Microsoft.Web.WebView2
          dotnet add LMSA.App/LMSA.App.csproj package Newtonsoft.Json

          # Test dependencies
          dotnet add LMSA.Tests/LMSA.Tests.csproj package Moq
          dotnet add LMSA.Tests/LMSA.Tests.csproj package FluentAssertions
          dotnet add LMSA.Tests/LMSA.Tests.csproj package coverlet.collector

          echo "Installed production dependencies"

      # Build the solution to verify setup
      - name: Build solution
        run: |
          dotnet restore LMSA.sln
          dotnet build LMSA.sln --no-restore
          echo "Solution built successfully"

      # Cache build artifacts and reference sources
      - name: Cache build and references
        uses: actions/cache@v4
        with:
          path: |
            decompiled/
            ~/.nuget/packages
          key: lmsa-build-${{ hashFiles('**/*.csproj', '.github/workflows/copilot-setup-steps.yml') }}
          restore-keys: |
            lmsa-build-
